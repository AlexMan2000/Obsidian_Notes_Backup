# Buffer Overflow Vulnerabilities
> [!link]
> Also in [Buffer Overflow](../../../Computer_Systems/Machine_Structures/3_X86_Assembly/X86_Advanced.md#Buffer%20Overflow) and [X86_Attack_Lab](../../../Computer_Systems/Machine_Structures/13_Projects_CSAPP_Labs/3_Assembly_Programming/X86_Attack_Lab.md)


## Authentication
> [!code]
> Note that both `char buf[8]` and `authenticated` are defined outside of the function, so they are both located in the static part of memory. 
> 
> **In C, static memory is filled in the order that variables are defined**, so `authenticated` is at a higher address in memory than `buf` (since static memory grows upward and `buf` was defined first, `buf` is at a lower memory address).
> 
> Imagine that elsewhere in the code, there is a login routine that sets the `authenticated` flag only if the user proves knowledge of the password. Unfortunately, the `authenticated` flag is stored in memory right after `buf`. Note that we use “after” here to mean “at a higher memory address”.
```c
char name[20];
int authenticated = 0;
void vulnerable() {
    gets(name);
}
```
> [!bug] Vulnerability
> ![](2_Memory_Vulnerability.assets/image-20240224153332446.png)
> If the attacker can write 21 bytes of data to `buf` (with the 21th byte set to a non-zero value), then this will set the `authenticated` flag to true, and the attacker will be able to gain access.
> 
> The program above allows that to happen, because the `gets` function does no bounds-checking; it will write as much data to `buf` as is supplied to it by the user. 
> 
> In other words, the code above is _vulnerable_: an attacker who can control the input to the program can **bypass the password checks.**



## CMD Program
> [!code]
```c
char line[512];
char command[] = "/usr/bin/ls";

int main(void) {
	...
	gets(line);
	...
	execv(command, ...);
}
```

> [!bug] Vulnerability
> ![](2_Memory_Vulnerability.assets/image-20240224153542577.png)
> If the attacker can write 513 bytes of data to `buf` (with the 513th byte set to a non-zero value), then this will set the `command` to other command, and the attacker will be able to execute any commands, like accessing all the files, shutting down the computer.
> 
> In other words, the code above is _vulnerable_: an attacker who can control the input to the program **can execute any commands**.





## Function Pointer
> [!code]
```c
char name[8];
int (*fnptr)(void);
void vulnerable() {
    gets(name);
}
```

> [!bug] Vulnerability
> ![](2_Memory_Vulnerability.assets/image-20240224153554996.png)
> `fnptr` is a _function pointer_. In memory, this is a 4-byte value that stores the address of a function. In other words, calling `fnptr` will cause the program to dereference the pointer and start executing instructions at that address.



## Stack Smashing Attack
> [!example] Overwrite the RIP
> ![](2_Memory_Vulnerability.assets/image-20240224154249408.png)![](2_Memory_Vulnerability.assets/image-20240224154302856.png)![](2_Memory_Vulnerability.assets/image-20240224154310604.png)

> [!summary]
> ![](2_Memory_Vulnerability.assets/image-20240224154335148.png)


## Code Injection Attack
> [!important] Constructing Method 1
> ![](2_Memory_Vulnerability.assets/image-20240224154509030.png)

> [!important] Constructing Method 2
> ![](2_Memory_Vulnerability.assets/image-20240224154535282.png)
> Note that since the address is 4 bytes, in the little endian system(mostly adopted), we should write the LSB to lower address. This is why `\xbf`(MSB) appears at the rightmost byte(higher address).
 
> [!important] Long Shellcode
> ![](2_Memory_Vulnerability.assets/image-20240224154808042.png)![](2_Memory_Vulnerability.assets/image-20240224154849457.png)


## Full Demo Example
> [!example]
> [[CS161 SP24] Lecture 3_ Memory Safety Vulnerabilities]([CS161%20SP24]%20Lecture%203_%20Memory%20Safety%20Vulnerabilities.pdf)


## Vulnerable C Library Functions
> [!important] Heap is Vulnerable
> ![](2_Memory_Vulnerability.assets/image-20240224155523662.png)

> [!important] C Library Functions
> ![](2_Memory_Vulnerability.assets/image-20240224155513990.png)




## How to Avoid Such Vulnerability
> [!important] Specify the Size
> ![](2_Memory_Vulnerability.assets/image-20240224155417114.png)![](2_Memory_Vulnerability.assets/image-20240224155428538.png)


# Format String Vulnerabilities
## Behaviors of printf()
> [!important]
> When the `printf(format_sequence, string)` function executes:
> - It looks for a format string modifier denoted by a “%” in its first argument located **4 bytes above the RIP** of `printf()`. 
> - **If it finds the modifier, it then looks 8 bytes above the RIP** for the “actual” argument (i.e. what the format modifier will be acting upon).
> 
> ![](2_Memory_Vulnerability.assets/image-20240224162300801.png)
> 
> The behavior of the `printf()` function is generally controlled by the format modifier(s) that are passed into the function. The `printf()` function retrieves the parameters that are requested by the format string from the stack. Take, for example, the following line of code: `printf("x has the value %d, y has the value %d, z has the value %d \n", x, y, z);` The stack frame for this line of code would look like:
> ![](2_Memory_Vulnerability.assets/image-20240224162256461.png)
> Remember that arguments to a function are pushed onto the stack in reverse order, which is why the address of the format string is at a lower address compared to the values of `x`, `y`, and `z`.
> 
> `printf()`’s internal pointer points to the location on the stack 8 bytes above the RIP of `printf()` due to the existence of at least one format string modifier. This internal pointer tells the function where to find the actual arguments that will be modified and eventually printed out.

> [!bug] Vulnerability
> When there is a **mismatch** in the number of format string modifiers in the first argument and number of additional arguments, the compiler are not sophisticated enough to check this for you. Since `printf()` is defined as a function with a variable number of arguments, as long as `printf()` receives at least one argument, everything looks fine to the compiler!
> 
> In other words, suppose our printf statement instead looked like this: `printf("x has the value %d, y has the value %d, z has the value %d \n", x, y);` where we have three modifiers but only two arguments passed in. Then, `printf()` simply fetches arguments from the stack according to the number of format modifiers that are present. **In cases of a mismatch, it will fetch some data from the stack that does not belong to the function call.**
> 
> In detail, the `printf()` function’s internal pointer will start off 8 bytes above the RIP (since it realizes that there is at least one format modifier present). Thus, the `printf()` function takes the value 8 bytes above the RIP and prints out whatever is located there; in other words, the first `%d` consumes the value located 8 bytes above the RIP of `printf()`. 
> 
> Once this happens, the `printf()` function locates the next format string modifier (the second `%d`), and moves its internal pointer 4 bytes up (so now, the internal pointer is pointing 12 bytes above the RIP of `printf()`), before printing out the value located there. Finally, the `printf()` function will locate the third format string modifier, and again move its internal pointer 4 bytes up (the internal pointer is now pointing 16 bytes above the RIP of `printf()`). 
> 
> However, we never actually passed in a third argument to the `printf()` function, so the value located 16 bytes above the RIP of `printf()` has nothing to do with the `printf()` function at all and is instead some value left over from the previous stack frame. Since the `printf()` function does not know this, however, it looks 16 bytes above the RIP of `printf()` and prints out the value located there.
> 
> Similar to how the `%d` format modifier simply makes the `printf()` function print the value located at the expected address, various format string modifiers have different uses.




## Useful Modifers
> [!important]
>  Here are a couple of examples that might be useful:
> - %s → **Treat the argument as an address** and print the string at that address up until the first null byte. **Could be used to read content from the memory address outside the stack.**
> - %n → **Treat the argument as an address** and write the number of characters that have been printed so far to that address.
> - %c → Treat the argument as a value and print it out as a character.
> - %[b]c -> Treat the argument as a value and print it out as a character, padded to [b] bytes. **Could be used to control the number of bytes printed and walk up arbitrary bytes up on the stack.** Here one %c looks 4 bytes up the stack, %94c also looks 4 bytes up the stack but print 94 bytes out instead of 1 byte.
> - %x → Look at the stack and read the first variable after the format string.
> - %[b]u → Print out [b] bytes starting from the argument.
> 
> **The bottom line**: _If your program has a format string vulnerability, assume that the attacker can learn any value stored in memory and can take control of your program._

> [!quiz] Concept Check
> ![](2_Memory_Vulnerability.assets/image-20240305084715113.png)![](2_Memory_Vulnerability.assets/image-20240305085010971.png)



## Format String Vulnerabilities
> [!overview]
> In short, this vulnerability is caused by the behavior of `printf()` where if there is modifers in the format sequence, the `printf()` will look up corresponding address above `RIP` of `printf()` for the value to print out. 
> 
> So if there is a mismatch in the argument(i.e. more modifiers than actual arguments), then the `printf()` will read memory address that is undefined to users.

> [!bug] Vulnerabilities - Leaking Values from the Stack
> ![](2_Memory_Vulnerability.assets/image-20240224163838496.png)![](2_Memory_Vulnerability.assets/image-20240224163349237.png)![](2_Memory_Vulnerability.assets/image-20240224164255782.png)


## Attacking Examples
### Using \%d\%s to read
> [!example]
> ![](2_Memory_Vulnerability.assets/image-20240224164551778.png)


### Using \%n to write
> [!example]
> ![](2_Memory_Vulnerability.assets/image-20240224164639415.png)![](2_Memory_Vulnerability.assets/image-20240224164645185.png)![](2_Memory_Vulnerability.assets/image-20240224164651001.png)


### Write 100 to Address
> [!example]
> ![](2_Memory_Vulnerability.assets/image-20240224165803427.png)![](2_Memory_Vulnerability.assets/image-20240224165816392.png)![](2_Memory_Vulnerability.assets/image-20240224165853319.png)![](2_Memory_Vulnerability.assets/image-20240224165902109.png)



### Using \%c\%x to read
> [!example] Sp24 Disc03 P2
> ![](2_Memory_Vulnerability.assets/image-20240225150758100.png)![](2_Memory_Vulnerability.assets/image-20240225150814878.png)![](2_Memory_Vulnerability.assets/image-20240225150821429.png)![](2_Memory_Vulnerability.assets/image-20240225150828269.png)![](2_Memory_Vulnerability.assets/image-20240225150835966.png)
> For question 2.4, since we know that stack canary appears between `SFP` and current `EBP`, and since `buf[16]` occupies 16 bytes, we can compute the address of stack canary by `0xffffd8d8+0x10=0xffffd8e8`.
> 
> Also `printf(i)` can be used where `i` is treated as an address, which gives us large freedom to print whatever in that address out if the string representation of `i` doesn't contain any format modifiers.






## How to Avoid? 
> [!example]
> ![](2_Memory_Vulnerability.assets/image-20240224165954423.png)
> It means never put `buf` as the first argument to `printf()` (i.e. format sequence).




# Integer Conversion Vulnerabilities
## Stack Example
> [!code] Stack Example
> The following code has integer conversion vulnerabilities.
> 
> The function definition for `memcpy()` is:
> `void *memcpy(void *dest, const void *src, size_t n);`
> and the definition of `size_t` is :
> `typedef unsigned int size_t;`
```c
char buf[8];
void vulnerable() {
    int len = read_int_from_network();
    char *p = read_string_from_network();
    if (len > 8) {
        error("length too large: bad dog, no cookie for you!");
        return;
    }
	// Here if len is negative number, memcpy will implicitly type cast len to be unsigned int, which is huge.
    memcpy(buf, p, len);
}

```
> [!bug] Vulnerability
> If the attacker provides a negative value for `len`, the `if` statement won’t notice anything wrong, and `memcpy()` will be executed with a negative third argument. C will cast this negative value to an `unsigned int` and it will become a very large positive integer. Thus `memcpy()` will copy a huge amount of memory into `buf`, overflowing the buffer.
> 
> Note that the C compiler won’t warn about the type mismatch between `signed int` and `unsigned int`; it silently inserts an implicit cast. This kind of bug can be hard to spot. 
> 
> The above example is particularly nasty, because on the surface it appears that the programmer has applied the correct bounds checks, but they are flawed.



## Heap Example
> [!code]
```c
void vulnerable() {
    size_t len;
    char *buf;

    len = read_int_from_network();
    buf = malloc(len+5);
    read(fd, buf, len);
    ...
}
```

> [!bug] Vulnerabilities
> This code seems to avoid buffer overflow problems (indeed, it allocates 5 more bytes than necessary). But, there is a subtle problem: `len+5` can wrap around if `len` is too large. For instance, if `len = 0xFFFFFFFF`, then the value of `len+5` is `4` (on 32-bit platforms). 
> 
> In this case, the code allocates a 4-byte buffer and then writes a lot more than 4 bytes into it: a classic buffer overflow. You have to know the semantics of your programming language very well to avoid all the pitfalls.


## How to Avoid?
> [!important]
> ![](2_Memory_Vulnerability.assets/image-20240224160845830.png)




# Off-By-One Vulnerabilities(Fencepost)
> [!def]
> Off-by-one errors are very common in programming: for example, you might accidentally use `<=` instead of `<`, or you might accidentally start a loop at `i=0` instead of `i=1`. As it turns out, even an off-by-one error can lead to dangerous memory safety vulnerabilities.
> 
> In short, off-by-one attack utilize the step 8 of X86 CALL procedure where it moves ESP to maliciously modified state of EBP(where the shellcode begins), then step 9 and step 10 will pop EBP and EIP but now EBP and EIP are part of our shellcode, then popping EIP in step 10 will start the attack. 

> [!bug] Vulnerability
> ![](2_Memory_Vulnerability.assets/image-20240224203515287.png)![](2_Memory_Vulnerability.assets/image-20240224203523482.png)![](2_Memory_Vulnerability.assets/image-20240224203528957.png)![](2_Memory_Vulnerability.assets/image-20240224203535251.png)![](2_Memory_Vulnerability.assets/image-20240224203541400.png)![](2_Memory_Vulnerability.assets/image-20240224203549574.png)![](2_Memory_Vulnerability.assets/image-20240224203558979.png)![](2_Memory_Vulnerability.assets/image-20240224203607493.png)![](2_Memory_Vulnerability.assets/image-20240224203629235.png)![](2_Memory_Vulnerability.assets/image-20240224203637291.png)![](2_Memory_Vulnerability.assets/image-20240224203647849.png)![](2_Memory_Vulnerability.assets/image-20240224203657219.png)







# Heap Vulnerabilities





# C++ VTable Vulnerabilities






# Chapter Exercises
## Searching for Vulnerabilities
### Vulnerability Potpourri
> [!example] Sp24 Disc02 P1
> ![](2_Memory_Vulnerability.assets/image-20240225114426623.png)![](2_Memory_Vulnerability.assets/image-20240225114528269.png)
> Note that here fencepost is just off-by-one error.
> 
> In summary, we list al the vulnerabilities:
> - Line 12, Off-by-One Vulnerability, since the bound check is wrong where it should be `i < n`.
> - Line 12, Integer Conversion Vulnerability, since i has type `size_t`(actually `unsigned int`), when we evaluate `i <= n`, `n` is implicitly converted(casted) to `unsigned int` , thus if `n` is a large negative values, then after conversion, `n` evaluates to huge positive number, which causes the loop to run for lots of time.
> - Line 15, Buffer Overflow Vulnerability, since `strcpy` is not a memory-safe function and if the attacker controls the `owner_name`, we could overflow the buffer.
> - Line 21, Format String Vulnerability, since we pass a attacker-controlled `buf` into the first argument of `printf()`, so it is not memory-safe.


## Design Attacking Schemes
### Buffer Overflow Attack
> [!example] Sp24 Disc02 P2
> Notes on `fread()` function:
> ![](2_Memory_Vulnerability.assets/image-20240225120058319.png)![](2_Memory_Vulnerability.assets/image-20240225123933087.png)![](2_Memory_Vulnerability.assets/image-20240225123941919.png)


### Code Injection - Think Downwards
> [!example] Sp24 Disc02 P3
> ![](2_Memory_Vulnerability.assets/image-20240225132208350.png)![](2_Memory_Vulnerability.assets/image-20240225132214896.png)![](2_Memory_Vulnerability.assets/image-20240225132221859.png)


### Heap and Stack Indirection - Use of Pointers
> [!example] Sp24 Exam Prep 02 P1
> ![](2_Memory_Vulnerability.assets/image-20240225135002216.png)![](2_Memory_Vulnerability.assets/image-20240225133043234.png)![](2_Memory_Vulnerability.assets/image-20240225133049691.png)
> Here, the key thing to realize is that `entry->msg` is a pointer that holds an address, this address could be a heap address or a stack address.



### Stack Exchange - Use of Pointers
> [!example] Sp24 Exam Prep 02 P2
> ![](2_Memory_Vulnerability.assets/image-20240225135622479.png)![](2_Memory_Vulnerability.assets/image-20240225135812319.png)![](2_Memory_Vulnerability.assets/image-20240225135819934.png)![](2_Memory_Vulnerability.assets/image-20240225135827592.png)


### Stack Exchange - Palindromes
> [!example] Sp24 Exam Prep 02 P3
> ![](2_Memory_Vulnerability.assets/image-20240225143953496.png)![](2_Memory_Vulnerability.assets/image-20240225143959689.png)![](2_Memory_Vulnerability.assets/image-20240225144005895.png)![](2_Memory_Vulnerability.assets/image-20240225144012705.png)



 

# Serialization - Log4j